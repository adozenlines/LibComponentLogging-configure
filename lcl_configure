#!/usr/bin/env ruby

#
#
# lcl_configure -- LibComponentLogging, configuration
#
#
# Copyright (c) 2014 Arne Harren <ah@0xc0.de>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

require 'FileUtils'
require 'Pathname'
require 'JSON'
require 'Digest'


#
# Usage, info, error, etc.
#

@usage=<<END
usage: lcl_configure <type> [<folder>]
END

def print_usage_and_exit(message = '')
  puts message if message != ''
  puts @usage
  exit
end

def error(message)
  puts message
  exit
end

def info(message)
  puts message
end

def note(message)
  puts '[!] ' + message
end


#
# File/directory utilities.
#

def exists_directory(directory_name)
  return File.directory?(directory_name)
end

def exists_file(file_name)
  return File.file?(file_name)
end

def create_file(file_name)
  FileUtils.rm(file_name) if exists_file(file_name)
  FileUtils.touch(file_name)
end

def copy_file(src_file_name, dst_file_name)
  FileUtils.cp(src_file_name, dst_file_name)
end

def append_to_file(file_name, content)
  File.open(file_name, 'a') do |f|
    f.puts(content)
  end
end

def replace_file(file_name, content)
  File.open(file_name, 'w') do |f|
    f.puts(content)
  end
end

#
# Handling of lcl_configure sections
#

@lcl_configure_section_begin = "/*::lcl_configure:begin::*/\n"
@lcl_configure_section_end = '/*::lcl_configure:end::*/'
@lcl_configure_section_empty = @lcl_configure_section_begin + '' + @lcl_configure_section_end
@lcl_configure_section_match = /^\/\*\:\:lcl_configure\:begin\:\:\*\/[\n\r]*(.*?)^\/\*\:\:lcl_configure\:end\:\:\*\//m

def lcl_configure_section_read_json_data_from_file(file_name)
  # Read the lcl_configure data from the given file.
  content = File.read(file_name)
  configure_section = lcl_configure_section_extract(content)
  return {} if !configure_section

  # Extract JSON part.
  configure_section =~ /^\/\*(.*)^\*\//m
  json_data = $1
  return {} if !json_data

  # Return parsed JSON data.
  parsed_json_data = JSON.parse(json_data)
  return parsed_json_data
end

def lcl_configure_section_insert_in_file(file_name, data)
  # Insert the given data into all lcl_configure sections inside the file
  content = File.read(file_name)
  configure_section = lcl_configure_section_extract(content)
  if !configure_section
    configure_section = lcl_configure_section_empty
  end
  content = content.gsub(@lcl_configure_section_match, lcl_configure_section_create(configure_section + data))
  replace_file(file_name, content)
end

def lcl_configure_section_extract(text)
  # Extract the text inside a lcl_configure section with the format
  #   /*::lcl_configure:begin::*/
  #   <data>
  #   /*::lcl_configure:end::*/
  text =~ @lcl_configure_section_match
  return $1
end

def lcl_configure_section_create(data)
  # Put the given data into a lcl_configure section:
  #   /*::lcl_configure:begin::*/
  #   <data>
  #   /*::lcl_configure:end::*/
  section = @lcl_configure_section_begin + data + @lcl_configure_section_end
  return section
end

def lcl_configure_section_clear(text)
  # Replace all lcl_configure sections with an empty section.
  text_new = text.gsub(@lcl_configure_section_match, @lcl_configure_section_empty)
  return text_new
end


#
# Standard configuration files, common parts.
#

@config_components_file_name = "lcl_config_components.h"
@config_logger_file_name = "lcl_config_logger.h"
@config_extensions_file_name = "lcl_config_extensions.h"

def prepare_configure_plain_create_config_file(file_name)
  # Create new config file if file does not exist.
  if !exists_file(file_name)
    info("Creating configuration file '#{file_name}'")
    create_file(file_name)
  end

  # Clear the lcl_configure section(s) inside the file.
  content = File.read(file_name)
  if (lcl_configure_section_extract(content))
    content = lcl_configure_section_clear(content)
  else
    content += @lcl_configure_section_empty
  end
  replace_file(file_name, content)
end

def prepare_configure_plain()
  # Create all three config files.
  prepare_configure_plain_create_config_file(@config_components_file_name)
  prepare_configure_plain_create_config_file(@config_logger_file_name)
  prepare_configure_plain_create_config_file(@config_extensions_file_name)
end


#
# Configuration for plain installations.
#

def configure_plain()
  # Prepare configuration files.
  prepare_configure_plain()
end


#
# Configuration for CocoaPods installations.
#

def configure_pod_core(pod_dir, pod_name, configure_file, configure_data)
  # Nothing to do for core.
end

def configure_pod_logger(pod_dir, pod_name, configure_file, configure_data)
  # Add header file.
  main_header = configure_data['main_header']
  error("Error: missing 'main_header' in '#{configure_file}'") if !main_header
  content = "#include \"#{main_header}\"\n"
  lcl_configure_section_insert_in_file(@config_logger_file_name, content)

  # Instantiate configuration template file (optional).
  config_template = configure_data['config_template']
  configure_pod_instantiate_config_template(pod_dir, config_template) if config_template
end

def configure_pod_extension(pod_dir, pod_name, configure_file, configure_data)
  # Add header file.
  main_header = configure_data['main_header']
  error("Error: missing 'main_header' in '#{configure_file}'") if !main_header
  content = "#include \"#{main_header}\"\n"
  lcl_configure_section_insert_in_file(@config_extensions_file_name, content)

  # Instantiate configuration template file (optional).
  config_template = configure_data['config_template']
  configure_pod_instantiate_config_template(pod_dir, config_template) if config_template
end

def configure_pod_instantiate_config_template(pod_dir, config_template)
  config_template_file = Pathname(pod_dir) + config_template
  config_template_sha256 = Digest::SHA256.file(config_template_file).hexdigest
  config_file_name = config_template.gsub(/\.template/, '')
  if exists_file(config_file_name)
    # We've stored the SHA256 hash of the original file inside a
    #   /*::lcl_configure:begin::*/
    #     <JSON-encoded data>
    #   /*::lcl_configure:end::*/
    # section in the configuration file.
    # If the stored hash matches the hash of the current template file,
    # then we assume that the existing configuration file originates from that
    # template file. Then, there's nothing to do.
    data = lcl_configure_section_read_json_data_from_file(config_file_name)
    if data['base'] != config_template_sha256
      # Existing file doesn't originate from template file, create .new file.
      info("Creating configuration file '#{config_file_name}' from template '#{config_template_file}'")
      config_new_file_name = config_file_name + '.new'
      configure_pod_copy_file_with_lcl_configure_data(config_template_file, config_template_sha256, config_new_file_name)
      note("Configuration file '#{config_file_name}' already exists, please merge with new file '#{config_new_file_name}'")
    end
  else
    # Create configuration file, based on template file. Store the SHA256 hash
    # of the template file inside a
    #   /*::lcl_configure:begin::*/
    #     <JSON-encoded data>
    #   /*::lcl_configure:end::*/
    # section in the created configuration file.
    info("Creating configuration file '#{config_file_name}' from template '#{config_template_file}'")
    configure_pod_copy_file_with_lcl_configure_data(config_template_file, config_template_sha256, config_file_name)
    note("Configuration file '#{config_file_name}' needs to be adapted before compiling your project, e.g. adapt '<UniquePrefix>'")
  end
end

def configure_pod_copy_file_with_lcl_configure_data(config_template_file, config_template_sha256, file_name)
  # Copy the file and add a lcl_configure data at the end.
  copy_file(config_template_file.to_s, file_name)
  data = <<END
/*
  {
    "base" : "#{config_template_sha256}"
  }
*/
END
  data = lcl_configure_section_create(data)
  append_to_file(file_name, data)
end


def contained_in_podfile_lock(pod_name)
  # The Podfile.lock contains the following data (CocoaPods 0.33.1):
  # PODS:
  # - <pod_name_1> (<version_1>)
  # - <pod_name_2> (<version_2>)
  # ...
  # As the pod name might be the prefix of another pod, e.g. LibComponentLogging-NSLog
  # is a prefix of LibComponentLogging-NSLogger, we search for "<pod name> ".
  # We don't expect that LibComponentLogging-xyz is a suffix of another pod.
  content = File.read('Podfile.lock')
  return content.include?(pod_name + ' ')
end

# Configure for CocoaPods.
def configure_pod()
  # Check existence of CocoaPods files and directories.
  error("Error: no 'Podfile' file found") if !exists_file('Podfile')
  error("Error: no 'Podfile.lock' file found") if !exists_file('Podfile.lock')
  error("Error: no 'Pods' directory found") if !exists_directory('Pods')

  # Prepare config files.
  prepare_configure_plain()

  # Used core and logger pods.
  pod_name_core = nil
  pod_name_logger = nil

  # Search for pod.lcl_configure files inside the Pods directory.
  Dir.glob('Pods/**/pod.lcl_configure').each do |configure_file|
    # Extract name of pod from path.
    pod_dir = File.dirname(configure_file)
    pod_name = File.basename(pod_dir).to_s

    # Check Podfile.lock.
    next if !contained_in_podfile_lock(pod_name)

    # Read and parse the pod.lcl_configure file.
    # The file has the following structure:
    # {
    #   "name"           : "<name>",
    #   "type"           : "<type>",            // core, logger, extension
    #   "main_header"    : "<file>.h",
    #   "config_template": "<file>.template.h"  // optional
    # }
    configure_data = JSON.parse(File.read(configure_file))
    type = configure_data['type']
    error("Error: missing 'type' in '#{configure_file}'") if !type
    name = configure_data['name']
    error("Error: missing 'name' in '#{configure_file}'") if !type

    # Process configure file.
    case type
      when 'core'
        error("Error: cannot use '#{pod_name}' as core, '#{pod_name_core}' is already used") if pod_name_core
        info("Using #{pod_name} (#{type})")
        configure_pod_core(pod_dir, pod_name, configure_file, configure_data)
        pod_name_core = pod_name
      when 'logger'
        error("Error: cannot use '#{pod_name}' as logger, '#{pod_name_logger}' is already used") if pod_name_logger
        info("Using #{pod_name} (#{name} #{type})")
        configure_pod_logger(pod_dir, pod_name, configure_file, configure_data)
        pod_name_logger = pod_name
      when 'extension'
        info("Using #{pod_name} (#{name} #{type})")
        configure_pod_extension(pod_dir, pod_name, configure_file, configure_data)
      else
        error("Error: pod '#{pod_name}' has unsupported type '#{type}'")
    end
  end
end

def main(args)
  type = args[0]
  print_usage_and_exit('Error: missing argument <type>') if !type

  folder = args[1]
  folder = '.' if !folder

  case type
    when 'plain'
      Dir.chdir(folder) do
        configure_plain()
      end
    when 'pod'
      Dir.chdir(folder) do
        configure_pod()
      end
    else
      print_usage_and_exit("Error: unknown type '#{type}', available types are 'plain', 'pod'")
  end

  exit
end

main(ARGV)
